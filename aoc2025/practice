module aoc2025.day08

open System
open System.Collections.Generic
open aoc2025.util
open aoc2025.util.Grid

type Depth = { Vert: int; Horiz: int }

type Diagonal =
    | UL
    | UR
    | DL
    | DR

let isOutOfBonds p boundaries =
    not (
        p.x >= boundaries.minX
        && p.x <= boundaries.maxY
        && p.y >= boundaries.minY
        && p.y <= boundaries.maxY
    )

let getPos p depth dir =
    (match dir with
     | UL -> (p.x - depth.Horiz, p.y - depth.Vert)
     | DL -> (p.x - depth.Horiz, p.y + depth.Vert)
     | UR -> (p.x + depth.Horiz, p.y - depth.Vert)
     | DR -> (p.x + depth.Horiz, p.y + depth.Vert))
        .AsP2D()


let explored = Dictionary<Tuple<P2D, P2D, Depth>, bool>()

let alg sp bound freqLocations =

    let rec loop depth resonantNodes =
        let nodes =
            [ UL; UR; DL; DR ]
            |> Seq.map (fun d -> ((d, depth), getPos sp depth d))
            |> Seq.where (fun (_, p) -> (not (isOutOfBonds p bound)) && (not (explored.ContainsKey(sp, p, depth))))
            |> Seq.toList

        nodes |> Seq.iter (fun (_, p) -> explored[(sp, p, depth)] <- true)

        if nodes |> Seq.isEmpty then
            resonantNodes
        else
            let resonantNodes =
                resonantNodes
                @ (nodes
                   |> Seq.where (fun (_, p) -> freqLocations |> Seq.tryFind (fun fl -> fl = p) |> Option.isSome)
                   |> Seq.toList)

            let anodes =
                [ (1, 0); (0, 1) ]
                |> List.map (fun t ->
                    let depth =
                        { Vert = depth.Vert + fst t
                          Horiz = depth.Horiz + snd t }

                    loop depth resonantNodes)


            anodes |> List.collect id

    let resonantNodes = loop { Vert = 1; Horiz = 1 } []

    let anodes =
        resonantNodes
        |> List.map (fun ((d, depth), p) -> getPos p depth d)
        |> List.where (fun p -> not (isOutOfBonds p bound))

    anodes


let solve () =
    let io = new aocIO 2024
    let inp = io.getInput ()

    let gr = initializeFromStringSeq inp
    let boundaries = gr |> getBoundary

    let frequencies =
        gr |> mapIndexes |> Seq.where (fun (fst, snd) -> snd <> '.') |> Seq.groupBy snd

    let mutable anodes = []

    for i in 0 .. (frequencies |> Seq.length) - 1 do
        let f = snd (frequencies |> Seq.item i) |> Seq.map fst

        for x in f do
            let r = alg x boundaries f
            anodes <- anodes @ r

    let nAnodes = anodes |> Seq.distinct |> Seq.length
    gr.Print()
    printfn $"%A{nAnodes}"

    0
